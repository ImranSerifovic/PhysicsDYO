<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<head>
    <title>Euler Fluid</title>
    <style>
        body {
            font-family: verdana;
            font-size: 15px;
        }

        .button {
            background-color: #9AC8CD;
            border: none;
            color: white;
            padding: 10px 10px;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
        }

        .slider {
            -webkit-appearance: none;
            width: 80px;
            height: 6px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }
    </style>
</head>

<body>
    <br>
    <canvas id="myCanvas" style="border:2px solid"></canvas>

    <script>
        var canvas = document.getElementById("myCanvas");
        var c = canvas.getContext("2d");
        canvas.width = window.innerWidth - 20;
        canvas.height = window.innerHeight - 100;
        canvas.focus();

        var simHeight = 1.1;
        var cScale = canvas.height / simHeight;
        var simWidth = canvas.width / cScale;

        var U_FIELD = 0;
        var V_FIELD = 1;
        var S_FIELD = 2;

        var cnt = 0;

        function cX(x) {
            return x * cScale;
        }

        function cY(y) {
            return canvas.height - y * cScale;
        }

        // ----------------- start of simulator ------------------------------

        class Fluid {
            constructor(density, numX, numY, h) {
                this.density = density;
                this.numX = numX + 2;
                this.numY = numY + 2;
                this.numCells = this.numX * this.numY;
                this.h = h;
                this.u = new Float32Array(this.numCells);
                this.v = new Float32Array(this.numCells);
                this.newU = new Float32Array(this.numCells);
                this.newV = new Float32Array(this.numCells);
                this.p = new Float32Array(this.numCells);
                this.s = new Float32Array(this.numCells);
                this.m = new Float32Array(this.numCells);
                this.newM = new Float32Array(this.numCells);
                this.m.fill(1.0);
                var num = numX * numY;
            }

            integrate(dt, gravity) {
                var n = this.numY;
                for (var i = 1; i < this.numX; i++) {
                    for (var j = 1; j < this.numY - 1; j++) {
                        if (this.s[i * n + j] != 0.0 && this.s[i * n + j - 1] != 0.0)
                            this.v[i * n + j] += gravity * dt;
                    }
                }
            }

            solveIncompressibility(numIters, dt) {

                var n = this.numY;
                var cp = this.density * this.h / dt;

                for (var iter = 0; iter < numIters; iter++) {

                    for (var i = 1; i < this.numX - 1; i++) {
                        for (var j = 1; j < this.numY - 1; j++) {

                            if (this.s[i * n + j] == 0.0)
                                continue;

                            var s = this.s[i * n + j];
                            var sx0 = this.s[(i - 1) * n + j];
                            var sx1 = this.s[(i + 1) * n + j];
                            var sy0 = this.s[i * n + j - 1];
                            var sy1 = this.s[i * n + j + 1];
                            var s = sx0 + sx1 + sy0 + sy1;
                            if (s == 0.0)
                                continue;

                            var div = this.u[(i + 1) * n + j] - this.u[i * n + j] +
                                this.v[i * n + j + 1] - this.v[i * n + j];

                            var p = -div / s;
                            p *= scene.overRelaxation;
                            this.p[i * n + j] += cp * p;

                            this.u[i * n + j] -= sx0 * p;
                            this.u[(i + 1) * n + j] += sx1 * p;
                            this.v[i * n + j] -= sy0 * p;
                            this.v[i * n + j + 1] += sy1 * p;
                        }
                    }
                }
            }

            extrapolate() {
                var n = this.numY;
                for (var i = 0; i < this.numX; i++) {
                    this.u[i * n + 0] = this.u[i * n + 1];
                    this.u[i * n + this.numY - 1] = this.u[i * n + this.numY - 2];
                }
                for (var j = 0; j < this.numY; j++) {
                    this.v[0 * n + j] = this.v[1 * n + j];
                    this.v[(this.numX - 1) * n + j] = this.v[(this.numX - 2) * n + j]
                }
            }

            sampleField(x, y, field) {
                var n = this.numY;
                var h = this.h;
                var h1 = 1.0 / h;
                var h2 = 0.5 * h;

                x = Math.max(Math.min(x, this.numX * h), h);
                y = Math.max(Math.min(y, this.numY * h), h);

                var dx = 0.0;
                var dy = 0.0;

                var f;

                switch (field) {
                    case U_FIELD:
                        f = this.u;
                        dy = h2;
                        break;
                    case V_FIELD:
                        f = this.v;
                        dx = h2;
                        break;
                    case S_FIELD:
                        f = this.m;
                        dx = h2;
                        dy = h2;
                        break

                }

                var x0 = Math.min(Math.floor((x - dx) * h1), this.numX - 1);
                var tx = ((x - dx) - x0 * h) * h1;
                var x1 = Math.min(x0 + 1, this.numX - 1);

                var y0 = Math.min(Math.floor((y - dy) * h1), this.numY - 1);
                var ty = ((y - dy) - y0 * h) * h1;
                var y1 = Math.min(y0 + 1, this.numY - 1);

                return (1.0 - tx) * ((1.0 - ty) * f[x0 * n + y0] + ty * f[x0 * n + y1]) +
                    tx * ((1.0 - ty) * f[x1 * n + y0] + ty * f[x1 * n + y1]);
            }
        }

        class Scene {
            constructor(numX, numY) {
                this.fluid = new Fluid(1.0, numX, numY, 1.0 / numX);
                this.showVelocities = false;
                this.showDensity = true;
                this.showPressure = false;
                this.showObstacle = true;
                this.overRelaxation = 0.1;
            }

            setObstacle(x, y, w, h) {
                var n = this.fluid.numY;
                for (var i = Math.floor(x); i < Math.ceil(x + w); i++) {
                    for (var j = Math.floor(y); j < Math.ceil(y + h); j++) {
                        this.fluid.s[i * n + j] = 0.0;
                    }
                }
            }

            addDensity(x, y, amount) {
                this.fluid.m[Math.floor(x) * this.fluid.numY + Math.floor(y)] += amount;
            }

            addVelocity(x, y, amountX, amountY) {
                var n = this.fluid.numY;
                this.fluid.u[Math.floor(x) * n + Math.floor(y)] += amountX;
                this.fluid.v[Math.floor(x) * n + Math.floor(y)] += amountY;
            }

            update(dt) {
                this.fluid.extrapolate();
                this.fluid.integrate(dt, 0.0);
                this.fluid.solveIncompressibility(10, dt);
            }

            draw() {
                var fluid = this.fluid;
                var numX = fluid.numX;
                var numY = fluid.numY;
                var h = fluid.h;

                if (this.showDensity) {
                    c.beginPath();
                    c.fillStyle = 'red';
                    for (var i = 1; i < numX - 1; i++) {
                        for (var j = 1; j < numY - 1; j++) {
                            var x = (i - 0.5) * h;
                            var y = (j - 0.5) * h;
                            c.globalAlpha = fluid.m[i * numY + j] / 10.0;
                            c.fillRect(cX(x), cY(y), cX(h), cY(h));
                        }
                    }
                    c.closePath();
                }

                if (this.showVelocities) {
                    c.beginPath();
                    c.strokeStyle = 'blue';
                    c.lineWidth = 1;
                    for (var i = 1; i < numX - 1; i++) {
                        for (var j = 1; j < numY - 1; j++) {
                            var x = i * h;
                            var y = j * h;
                            var u = 0.5 * (fluid.u[i * numY + j] + fluid.u[(i + 1) * numY + j]);
                            var v = 0.5 * (fluid.v[i * numY + j] + fluid.v[i * numY + j + 1]);
                            c.moveTo(cX(x), cY(y));
                            c.lineTo(cX(x + u), cY(y + v));
                        }
                    }
                    c.stroke();
                    c.closePath();
                }

                if (this.showPressure) {
                    c.beginPath();
                    c.strokeStyle = 'black';
                    c.lineWidth = 1;
                    for (var i = 1; i < numX - 1; i++) {
                        for (var j = 1; j < numY - 1; j++) {
                            var x = (i - 0.5) * h;
                            var y = (j - 0.5) * h;
                            var p = fluid.p[i * numY + j];
                            c.moveTo(cX(x), cY(y));
                            c.lineTo(cX(x + p * 0.1), cY(y + p * 0.1));
                        }
                    }
                    c.stroke();
                    c.closePath();
                }

                if (this.showObstacle) {
                    c.beginPath();
                    c.fillStyle = 'gray';
                    for (var i = 0; i < numX; i++) {
                        for (var j = 0; j < numY; j++) {
                            if (fluid.s[i * numY + j] == 0.0) {
                                var x = i * h;
                                var y = j * h;
                                c.fillRect(cX(x), cY(y), cX(h), cY(h));
                            }
                        }
                    }
                    c.closePath();
                }
            }

            clear() {
                c.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        var scene = new Scene(128, 64);
        scene.setObstacle(40, 10, 20, 40);

        var dt = 0.03;

        function mainLoop() {
            scene.clear();
            scene.update(dt);
            scene.draw();
            cnt++;
            requestAnimationFrame(mainLoop);
        }

        requestAnimationFrame(mainLoop);

        canvas.addEventListener('click', function (event) {
            var rect = canvas.getBoundingClientRect();
            var mouseX = event.clientX - rect.left;
            var mouseY = event.clientY - rect.top;
            var x = mouseX / cScale;
            var y = (canvas.height - mouseY) / cScale;

            scene.addDensity(x, y, 100.0);
        });

        canvas.addEventListener('mousemove', function (event) {
            var rect = canvas.getBoundingClientRect();
            var mouseX = event.clientX - rect.left;
            var mouseY = event.clientY - rect.top;
            var x = mouseX / cScale;
            var y = (canvas.height - mouseY) / cScale;

            if (event.buttons == 1) {
                scene.addVelocity(x, y, 100.0, 0.0);
            }
        });
    </script>
</body>

</html>
